/**
 * External dependencies
 */
import { includes, forEach, trim, map, find, toLower, compact } from 'lodash'

/**
 * WordPress dependencies
 */
import { dispatch, select } from '@wordpress/data'
import { serialize, rawHandler } from '@wordpress/blocks'
import { doAction } from '@wordpress/hooks'

/**
 * Internal dependencies
 */
import { replaceClassicContent, setContent, removeTinyMceHighlighting } from './tinymceUtils'

/**
 * Replaces the specified blocks or old content with new AI-generated content
 * and highlights the updated content for easy identification.
 *
 * @param {string}          apiResponse The AI-generated content to replace the old content with.
 * @param {string|string[]} blocks      The old content or specific content blocks to be replaced.
 *
 * @return {void}
 */
export const replaceContent = ( apiResponse, blocks ) => {
	if ( rankMath.currentEditor === 'elementor' ) {
		doAction( 'rank_math_replace_ai_content', apiResponse )
		return
	}

	if ( rankMath.currentEditor === 'classic' ) {
		replaceClassicContent( apiResponse, blocks )
		return
	}

	const { replaceBlock, removeBlock } = dispatch( 'core/block-editor' )

	forEach( apiResponse, ( response ) => {
		let { action, refBlockId, content, position } = response

		const block = find( blocks, ( b ) => ( b.clientId === refBlockId ) )
		if ( ! block ) {
			console.warn( `Block with ID ${ refBlockId } not found.` )
			return
		}

		switch ( action ) {
			case 'replace':
				// Replace block content
				content = highlightContent( serialize( block ), content )
				replaceBlock( refBlockId, rawHandler( { HTML: content } ) )
				break

			case 'delete':
				// Delete block
				removeBlock( refBlockId )
				break

			case 'insert':
				// Insert new block at specified position.
				let index = blocks.indexOf( block )
				if ( index === -1 ) {
					return
				}

				index = position === 'before' ? index : index + 1
				content = highlightContent( '', content )
				const newBlocks = rawHandler( { HTML: content } )
				forEach( newBlocks, ( newBlock ) => {
					dispatch( 'core/block-editor' ).insertBlock( newBlock, index )
					index++
				} )
				break

			default:
				console.warn( `Unknown action: ${ action }` )
				break
		}
	} )
}

/**
 * Removes highlighted mark from the provided content and updates the editor
 * with the cleaned content.
 *
 * @param {string} content The content currently in the editor, which includes highlighted text.
 *
 * @return {void}
 */
export const removeHighlighting = ( content ) => {
	if ( ! content ) {
		return
	}

	if ( rankMath.currentEditor === 'classic' ) {
		removeTinyMceHighlighting()
		return
	}

	content = content.replace( /<mark class="rank-math-highlight" style="background-color: #fee894">(.+?)<\/mark>/g, '$1' )
	const blocks = rawHandler( { HTML: content } )
	restoreOriginalContent( blocks )
}

/**
 * Restores the content to its original state when the user rejects the changes
 * made by AI, typically triggered by the Reject button in the FixWithAISnackBar component.
 *
 * @param {Array|string[]} originalBlocks  The original content or content blocks to be restored.
 * @param {Array|string[]} originalContent The original contentto be restored.
 *
 * @return {void}
 */
export const restoreOriginalContent = ( originalBlocks, originalContent = '' ) => {
	if ( ! [ 'classic', 'gutenberg' ].includes( rankMath.currentEditor ) ) {
		return
	}

	if ( rankMath.currentEditor === 'classic' ) {
		setContent( originalContent )
		return
	}

	const allBlockClientIds = select( 'core/block-editor' ).getBlocks().map( ( block ) => block.clientId )
	dispatch( 'core/block-editor' ).replaceBlocks( allBlockClientIds, originalBlocks )

	// @Todo check why this function is not working.
	// wp.data.dispatch( 'core/editor' ).editPost( { content: props.content } )
}

/**
 * Compares the original content with AI-generated content, identifies changes,
 * and returns the AI-generated content with the differences highlighted.
 *
 * @param {string} originalContent    The content currently added in the editor.
 * @param {string} aiGeneratedContent The content generated by the AI to be compared.
 *
 * @return {string} The AI-generated content with highlights applied to the changes.
 */
export const highlightContent = ( originalContent, aiGeneratedContent ) => {
	originalContent = originalContent.replaceAll( '\n', '' )
	const originalSentences = getSentences( originalContent )
	const aiGeneratedSentences = getSentences( aiGeneratedContent )

	// Compare sentences and find differences
	const differences = []
	forEach( aiGeneratedSentences, ( aiSentence ) => {
		if ( includes( originalSentences, aiSentence ) ) {
			return
		}

		// If the AI-generated sentence doesn't exist in the original content, it's a new sentence
		differences.push( aiSentence )
	} )

	// Highlight differences in the AI-generated content
	let highlightedContent = aiGeneratedContent
	forEach( differences, ( aiSentence ) => {
		// Find the aiSentence in the aiGeneratedContent
		const originalSentenceWithHTML = findSentenceWithHTML( aiGeneratedContent, aiSentence )
		// Replace the original sentence with the highlighted version
		highlightedContent = highlightedContent.replace(
			originalSentenceWithHTML,
			`<mark class="rank-math-highlight" style="background-color: #fee894">${ originalSentenceWithHTML }</mark>`
		)
	} )

	return highlightedContent
}

/**
 * Finds a sentence within HTML content, preserving HTML tags from the original content.
 *
 * @param {string} originalContent The HTML content to search within.
 * @param {string} sentence        The sentence to find in the content (case-insensitive).
 * @return {string|null} The matched sentence with HTML tags preserved, or `null` if the sentence is not found.
 */
const findSentenceWithHTML = ( originalContent, sentence ) => {
	// Strip comments and extract content within tags
	const innerContent = originalContent
		.replace( /<!--.*?-->/gs, '' ) // Remove HTML comments
		.match( /<([a-z0-9]+)([^>]*)>(.*?)<\/\1>/is )?.[ 3 ] || '' // Extract content within tags

	// Normalize sentence and content for comparison
	const normalizedContent = trim( innerContent.replace( /<[^>]*>/g, '' ).toLowerCase().replace( /\s+/g, ' ' ) )
	const normalizedSentence = trim( sentence.toLowerCase().replace( /\s+/g, ' ' ) )

	// Locate the start index of the sentence in the stripped content
	const startIndex = normalizedContent.indexOf( normalizedSentence )
	// Sentence not found
	if ( startIndex === -1 ) {
		return null
	}

	// Extract the sentence with HTML intact
	let taglessIndex = 0
	let result = ''

	for ( let i = 0; i < innerContent.length; i++ ) {
		const char = innerContent[ i ]

		if ( char === '<' ) {
			// Copy HTML tags directly
			while ( i < innerContent.length && innerContent[ i ] !== '>' ) {
				result += innerContent[ i++ ]
			}
			result += innerContent[ i ] // Include closing '>'
		} else {
			// Track tagless content index
			if ( taglessIndex >= startIndex && taglessIndex < startIndex + normalizedSentence.length ) {
				result += char // Include matching characters
			}
			taglessIndex++
			// Stop after the sentence
			if ( taglessIndex >= startIndex + normalizedSentence.length ) {
				break
			}
		}
	}

	return trim( result )
}

/**
 * Extracts sentences from the given text, removes HTML tags and extra spaces,
 * and returns an array of clean sentences.
 *
 * @param {string} text The input text containing sentences, possibly with HTML tags and extra spaces.
 * @return {Array} An array of sentences with HTML tags and unnecessary spaces removed.
 */
const getSentences = ( text ) => {
	// Remove HTML tags from the text.
	text = toLower( text.replace( /<[^>]*>/g, '' ) )

	// Split the text into sentences using punctuation and new lines.
	const sentences = text.split( /(?<!\d)\.(?!\d)|[!?]|\n/ ) || [ text ]

	// Trim each sentence.
	return compact( map( sentences, ( sentence ) => trim( sentence ) ) )
}
